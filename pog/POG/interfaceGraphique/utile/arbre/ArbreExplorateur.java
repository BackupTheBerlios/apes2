/*
 * POG
 * Copyright (C) 2004 Team POG
  *
 * This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


/* Generated by Together */



package POG.interfaceGraphique.utile.arbre;


import java.awt.Component;
import java.awt.datatransfer.StringSelection;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.io.File;
import java.util.Arrays;
import java.util.Vector;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import POG.interfaceGraphique.action.Systeme;
import POG.utile.PogToolkit;

	
public class ArbreExplorateur extends Arbre implements DragSourceListener, DragGestureListener{


  /** << Impl\uFFFDmentation inutilis\uFFFDe de l'interface DragSourceListener >> */
  public void dragDropEnd(DragSourceDropEvent event) { }
  /** << Impl\uFFFDmentation inutilis\uFFFDe de l'interface DragSourceListener >> */
  public void dragEnter(DragSourceDragEvent event) {}
  /** << Impl\uFFFDmentation inutilis\uFFFDe de l'interface DragSourceListener >> */
  public void dragExit(DragSourceEvent event) {}
  /** << Impl\uFFFDmentation inutilis\uFFFDe de l'interface DragSourceListener >> */
  public void dragOver(DragSourceDragEvent event) {}
  /** << Impl\uFFFDmentation inutilis\uFFFDe de l'interface DragSourceListener >> */
  public void dropActionChanged(DragSourceDragEvent event) {}

  private DragSource _dragSource = null;

  private DefaultTreeModel model;

  private String path ;
  private ImageIcon iconeAffecte ;
  private ImageIcon iconeLibre ;

  public ArbreExplorateur(Systeme syst){

    super();

    lnkSysteme = syst;
    iconeAffecte = syst.getLnkPreferences().getIconeDefaut("fichier_affecte");
    iconeLibre = syst.getLnkPreferences().getIconeDefaut("fichier_libre");
    this._arbre = new JTree ()
    {
      public boolean isPathEditable(TreePath path)
      {
        return (this.editable && isFichier(((DefaultMutableTreeNode) path.getLastPathComponent()))) ;
      }
    } ;
    this._arbre.setCellRenderer(new IconesRenderer());
    _dragSource = new DragSource();
    _dragSource.createDefaultDragGestureRecognizer(this._arbre, DnDConstants.ACTION_MOVE, this);

    this._arbre.setEditable(true);
    this._arbre.addMouseListener(new ArbreExplorateurListener (this));
    this._arbre.setModel(new DefaultTreeModel(new DefaultMutableTreeNode()));
  }

	public void load(File ff){
		load();
		DefaultMutableTreeNode rr = (DefaultMutableTreeNode) model.getRoot();
		Vector vect = new Vector();
		File tmpff = ff;
		while (tmpff != null) {
			if (!tmpff.getName().equals(""))
				vect.add(tmpff.getName());
			tmpff = tmpff.getParentFile();
		}
		do {
			int i = 0;
			String toto = "";
			for (; (i < rr.getChildCount()) && !vect.contains(toto); i++)
				toto = (String) ((DefaultMutableTreeNode)rr.getChildAt(i)).getUserObject();
			rr = (DefaultMutableTreeNode) rr.getChildAt(i - 1);
		} while (!rr.getUserObject().equals(ff.getName()));
	  	TreePath tp = new TreePath(rr.getPath());
	  	this._arbre.scrollPathToVisible(tp);
	  	this._arbre.setSelectionPath(tp);
  	}

  public void load(){
    if (lnkSysteme.getlnkControleurPresentation().getlnkPresentation() != null)
      path = lnkSysteme.getlnkControleurPresentation().getlnkPresentation().lnkBibliotheque.getAbsolutePath();
    else
      return;

    File library = new File(path);

    /* cr?ation d'un noeud */
    DefaultMutableTreeNode racine = new DefaultMutableTreeNode(library.getName());

    ajout_dossier(library, racine);

    /* model de l'arbre */
    model = new DefaultTreeModel(racine)
        {
          public void valueForPathChanged(TreePath path, Object newValue)
          {
            if (isFichier ((DefaultMutableTreeNode) path.getLastPathComponent()))
            {
              // Effectue le renommage
              renommer( (DefaultMutableTreeNode) path.getLastPathComponent(),
                       (String) newValue);

              // Appel de la methode d'origine
              super.valueForPathChanged(path, newValue);
            }
          }
        };
    this._arbre.setModel(model);
    this._arbre.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  }

  public void ajout_dossier(File lecteur, DefaultMutableTreeNode noeud) {
    int i;
    File[] liste;
    /* listFiles retourne tous les nom de fichiers et de sous-r?pertoires contenu dans un r?pertoire*/
	try {
	    liste = lecteur.listFiles();
	    Arrays.sort(liste);
	      for (i = 0; i < liste.length; i++) {
	        /* on teste si c'est un r?pertoire */
	        if ( (liste[i].isDirectory() == true) && (liste[i].isHidden() == false)) {
	          /* sitel est le cas on cr?e un nouveau noeud */
	          DefaultMutableTreeNode sous_rep = new DefaultMutableTreeNode(liste[i].getName());
	          /*que l'on ajoute au noeud pr?c?dent */
	          noeud.add(sous_rep);
	          /* et on regarde le contenu de ce nouveau r?pertoire */
	          ajout_dossier(liste[i], sous_rep);
	        }
	        else if ( (liste[i].isFile() == true) && (liste[i].isHidden() == false)) {
	          noeud.add(new DefaultMutableTreeNode(liste[i].getName()));
	        }
	      }
    }
    catch (NullPointerException e) {
      //exception que l'on obtient lorsqu'il n'y a plus de r?pertoire ou de fichier
    }
  }

  /**
   * Demande le nouveau nom et lance le renommage
   * @param n Element a renommer
   */
  public void askRenommer (DefaultMutableTreeNode n)
  {
    this.get_arbre().startEditingAtPath(this.get_arbre().getSelectionPath());
  }

  /**
   * Lance le processus de renommage de l'objet selectionne
   * @param n Element a renommer
   * @param nom Nouveau nom de l'element selectionner
   */
  public void renommer (DefaultMutableTreeNode n, String nom)
  {
    // Generation du chemin dans l'arbre
    this.lnkSysteme.majLiensFichiers(this.getFichier(n), this.getChemin(n) + nom);
    n.setUserObject(nom);
    lnkSysteme.lnkFenetrePrincipale.getLnkControleurPanneaux().reload();
  }

  /**
   * Lance le processus d'edition de l'objet selectionne
   * @param n Element a editer
   */
  public void editer (DefaultMutableTreeNode n)
  {
    this.lnkSysteme.lancer_editeur(this.getFichier(n));
  }

  /**
   * Lance le processus de suppression de l'objet selectionne
   * @param n Element a supprimer
   */
  public void supprimer (DefaultMutableTreeNode n) {
  	boolean detruire = true;
  	if (lnkSysteme.estFichierAffecte(this.getFichier(n)))
  		detruire = PogToolkit.askYesNoQuestion(lnkSysteme.lnkFenetrePrincipale.getLnkLangues().valeurDe("questsuppfichassocie").replaceFirst("ARG0", n.toString()), false, lnkSysteme.lnkFenetrePrincipale) == PogToolkit._YES;
  	else
  		detruire = PogToolkit.askYesNoQuestion(lnkSysteme.lnkFenetrePrincipale.getLnkLangues().valeurDe("questsuppfich").replaceFirst("ARG0", n.toString()), false, lnkSysteme.lnkFenetrePrincipale) == PogToolkit._YES;
  	if (detruire) {
		(new File(this.getFichier(n))).delete();
		this.load();
  	}
  }


  /**
   * Retourne le chemin du fichier au noeud specifie
   * @param n Noeud correspondant au fichier
   * @return Chemin vers le fichier du noeud
   */
  private String getChemin (DefaultMutableTreeNode n)
  {
    // Generation du chemin dans l'arbre
    String chemin = this.path + File.separator ;
    TreeNode [] cheminTab = n.getPath();
    for (int i = 1 ; i < cheminTab.length - 1 ; i++)
    {
      chemin += cheminTab [i] + File.separator ;
    }

    return (chemin) ;
  }

  /**
   * Retourne le chemin complet vers le fichier du noeud specifie
   * @param n Noeud dont on souhaite avoir le chemin
   * @return Chemin vers le fichier correspondant au noeud
   */
  private String getFichier (DefaultMutableTreeNode n)
  {
    return (new String (this.getChemin(n) + n)) ;
  }

  /**
   * Determine si le noeud specifie dans l'arbre designe un fichier ou un repertoire
   * @param n Noeud de l'arbre dont on doit determiner le type
   * @return VRAI si le noeud est un fichier, FAUX sinon
   */
  public boolean isFichier (DefaultMutableTreeNode n)
  {
    return (new File (this.getFichier(n)).isFile()) ;
  }

  public void dragGestureRecognized(DragGestureEvent event)
  {
    DefaultMutableTreeNode noeud = (DefaultMutableTreeNode)_arbre.getLastSelectedPathComponent() ;
    if (isFichier(noeud))
    {
      String s = "CONT=> " + getFichier(noeud);
      StringSelection text = new StringSelection(s);
      _dragSource.startDrag(event, DragSource.DefaultMoveDrop, text, this);
    }
  }


  /**
   * @directed
   */
  public Systeme lnkSysteme;

  private class IconesRenderer
      extends DefaultTreeCellRenderer {

    public Component getTreeCellRendererComponent(
        JTree tree,
        Object value,
        boolean sel,
        boolean expanded,
        boolean leaf,
        int row,
        boolean hasFocus) {


      JLabel c ;
      if (leaf)
      {
        DefaultMutableTreeNode noeud = (DefaultMutableTreeNode) value;
        if (!noeud.isRoot() && ((String)noeud.getUserObject()).length() > 0)
        {
          String fichier = getFichier(noeud) ;
          if (PogToolkit.folderExists(fichier))
          {
            c = (JLabel)super.getTreeCellRendererComponent(
                tree, value, sel, true, false, row, hasFocus);
          }
          else
          {
            c = (JLabel)super.getTreeCellRendererComponent(
                tree, value, sel, expanded, leaf, row, hasFocus);

            if (lnkSysteme.estFichierAffecte(fichier))
              c.setIcon(iconeAffecte);
            else
              c.setIcon(iconeLibre);
          }
        }
        else
        {
          c = (JLabel)super.getTreeCellRendererComponent(
            tree, value, sel, expanded, leaf, row, hasFocus);
        }
      }
      else
      {
        c = (JLabel)super.getTreeCellRendererComponent(
          tree, value, sel, expanded, leaf, row, hasFocus);
      }
      return c;
    }
  }
}